# LogScope Backend

     _                ____                       
    | |    ___   __ _/ ___|  ___ ___  _ __   ___ 
    | |   / _ \ / _` \___ \ / __/ _ \| '_ \ / _ \
    | |__| (_) | (_| |___) | (_| (_) | |_) |  __/
    |_____\___/ \__, |____/ \___\___/| .__/ \___|
                |___/                |_|         

Version 1.0.0

## Overview

LogScope consists of two parts: a _frontend_ and a _backend_.

- The _frontend_ parses a specification written in Scope, and translates it to a C++ file named `contract.cpp`.
- The _backend_ imports the generated C++ file `contract.cpp` and performs the actual event monitoring in its main program.

This README file explains the **backend**. 

The **frontend** can be found [here](https://github.jpl.nasa.gov/logscope/frontend). It gives a broader introduction to LogScope
and contains links to documentation.

## Installing the LogScope Backend:

1. The LogScope backend is implemented in C++14 (the 2014 version). Earlier versions of C++ may or may not compile. Also the C++20 version may not compile since changes were made that are not backwards compatible. The backend has been developed with IntelliJ's Clion IDE for C++, but can be used in command line mode, which is recommended.
2. Install CMake: [https://cmake.org](https://cmake.org/). Note that it is perfectly ok also to use Make directly. CMake makes life easier, however, as it generates the Makefile from a much simpler input consisting just of the paths to files to be compiled.
3. Download the backend repository as a zip file and unzip it. This creates a directory named: `backend_master`. We are now ready to compile and run.
    
## Preparing the LogScope Backend for a Run

The installed LogScope is ready to compile and run with a particular example. You may skip to the next step (Compiling the LogScope Backend) to see how it works. 

However, when you want to create your own specifications and monitor your own event streams, the backend needs adjustment of two files at the top level:

1. `contract.cpp` : the monitor generated by the frontend from a specification. Once generated by the frontend, move/copy this file to here. The file generated by the frontend should not be edited.
2. `main.cpp` : this is the main program, which instantiates the monitor in `contract.cpp` and feeds it events.   

These files are currently populated with meaningful contents (our introductory example explained in the manual).
The file `contract.cpp` is generated by the frontend from this speification (in `examples/example6/spec.scope`):


```
/*
After submission of a flight software command with a name x,
a success of the command named $x$ must follow (with the same name),
and that command x cannot be re-submitted in between.
Furthermore, a command is only allowed to succeed
if it has been commanded in the past and not yet succeeded.
*/

monitor M3 {
  event command(cmd,kind), succeed(cmd)

  always {
    command(cmd : x, kind : "FSW") => Succeed(c : x)
    succeed(cmd : x) @ !Succeed(c : x) => error
  }

  hot Succeed(c) {
    succeed(cmd : c) => ok
    command(cmd : c) => error
  }
}
```

The file `main.cpp` contains the following main program:

```c++

// -------------
// Main program:
// -------------

#include "contract.h"

int main() {
    // Create a monitor from the generated code in contract.cpp:
    SpecObject contract = makeContract();

    // Set options for debugging purposes if needed:
    contract.options.SHOW_PROGRESS = 0;
    // value 0 : no debugging information printed.
    // value 1 : every event processed is printed together with internal monitor states.
    // value N > 1 : event count printed for every N'th event.

    // An example trace:
    list<Event> events = {
            Event(10, "command", {{"cmd",  "TURN"},
                                  {"kind", "FSW"}}),
            Event(20, "command", {{"cmd",  "TRACK"},
                                  {"kind", "FSW"}}),
            Event(30, "succeed", {{"cmd", "TURN"}}),
            Event(40, "command", {{"cmd",  "PICT"},
                                  {"kind", "FSW"}}),
            Event(50, "succeed", {{"cmd", "SEND"}}),
            Event(60, "command", {{"cmd",  "PICT"},
                                  {"kind", "FSW"}})
    };

    // Monitor the trace, event by event:
    for (Event &e : events) {
        contract.eval(e);
    };

    // Terminate monitoring:
    contract.end();

    // Process detected errors manually if needed:
    cout << endl << endl << "Processing the result:" << endl << endl;
    cout << contract.getEventCount() << " events processed" << endl;
    cout << contract.getErrorCount() << " errors encountered" << endl;
    cout << endl;
    vector<ErrorReport> errors = contract.getErrorReports();
    for (ErrorReport error : errors) {
        cout <<
             error.kind << ", " <<
             error.monitorName << ", " <<
             error.stateName << ", " <<
             error.binding << ", " <<
             error.eventCount << ", " <<
             error.transitionCount <<
             endl;
    }

    // To run examples in examples directory, e.g. example 7:
    // #include "examples/example7/example7.h"
    // Run all examples in example 7:
    // example7::test();
    // Run one of the examples:
    // example7::test1();
 }

```
        
## Compiling the LogScope Backend

1. Do: `cd backend_master`.
2. Do: `cmake CMakeLists.txt`. This creates a `Makefile` (and three other files that can be ignored).
3. Do: `make`. This compiles the C++ code.


## Running the LogScope Backend

1. Do: `./logscope`. This runs `main.cpp` of the compiled code. If this runs the installation is correct. The end of the output of the example main program already in the installation should be:

```
...
TransitionError, M3, INTERNAL__1, Binding(), 5, 2
TransitionError, M3, Succeed, Binding{{{"c","PICT"}}}, 6, 2
EndError, M3, Succeed, Binding{{{"c","PICT"}}}, -1, -1
EndError, M3, Succeed, Binding{{{"c","TRACK"}}}, -1, -1

Process finished with exit code 0
```

The example and the result of monitoring is explained futher in the manual:
[pdf](https://github.jpl.nasa.gov/logscope/frontend/tree/master/manual/logscope_manual.pdf).
 
## Developer

* [Klaus Havelund](http://www.havelund.com), Jet Propulsion Laboratory, USA

## Github Repositories

- [LogScope organization](https://github.jpl.nasa.gov/logscope) : containing all repositories
- [Front end](https://github.jpl.nasa.gov/logscope/frontend) : parser and translator from DSL to C++, written in Scala.
- [Back end](https://github.jpl.nasa.gov/logscope/backend) : monitoring engine written in C++.
- [Website](https://github.jpl.nasa.gov/logscope/logscope.github.io) : website.

## Copyright statement

Copyright 2021, by the California Institute of Technology. ALL RIGHTS RESERVED.
United States Government Sponsorship acknowledged. Any commercial use must be negotiated
with the Office of Technology Transfer at the California Institute of Technology.
This software may be subject to U.S. export control laws. By accepting this software,
the user agrees to comply with all applicable U.S. export laws and regulations. User has
the responsibility to obtain export licenses, or other export authority as may be required before exporting such information to foreign countries or providing access to foreign persons.    
